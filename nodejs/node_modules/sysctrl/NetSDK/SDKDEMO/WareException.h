/************************************************************************
* 文件名称： WareException.h
* 文件标识： 
* 内容摘要： 程序异常、崩溃转储设置，程序崩溃时会自动生成DUMP文件到指定目录
* 其它说明： 
* 当前版本： 1.0.20130422
* 作    者： liuchen
* 版权所有 (C)2013
************************************************************************/

#pragma once

#include <stdio.h>
#include <stdlib.h>
#include "windows.h"
#include "DbgHelp.h"
#include "eh.h"   ///  Win 98, Win Me, Win NT, Win 2000, Win XP

#pragma comment(lib, "DbgHelp.lib")

#define GIE_DUMP_FILE_PATH	_T("GIE_CRASH\\")	//OCX崩溃时转储文件目录

//BEGIN_WARECOMMON

typedef bool ( WINAPI * MINIDUMPWRITEDUMP) // Callback函数的原型
(	HANDLE hProcess , 
	DWORD dwPid, 
	HANDLE hFile, 
	MINIDUMP_TYPE DumpType, 
	CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, 
	CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, 
	CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam );

//SetUnhandledExceptionFilter Unhandled Exception 出现的时候，转向的Callback
LONG WINAPI UnHandledExceptionFilter( struct _EXCEPTION_POINTERS* exceptionInfo );

/// _set_se_translator 转化成C++的结构化异常 不支持多线程
/// In a multithreaded environment, translator functions are maintained separately for each thread.
// Each new thread needs to install its own translator function.
// Thus, each thread is in charge of its own translation handling. 
// _set_se_translator is specific to one thread; 
// another DLL can install a different translation function.
void _se_trans_func( unsigned int, EXCEPTION_POINTERS* );

//typedef void ( *terminate_handler )();
void terminate_func();

void unexcepted_function();

void _pure_call_handler();

//// vs2005才支持, 这里暂时放在这里，以后激活
//_invalid_parameter_handler
typedef void (*_invalid_parameter_handler)( const wchar_t* expression, const wchar_t* function, const wchar_t* file, unsigned int line, uintptr_t pReserved ); 
void InvalidParameterHandler( const wchar_t* expression,
							  const wchar_t* function,
							  const wchar_t* file,
							  unsigned int line,
							  uintptr_t pReserved
);

void DisableSetUnhandledExceptionFilter()
{
	void *addr = (void*)GetProcAddress(LoadLibrary("kernel32.dll"),
		"SetUnhandledExceptionFilter");
	if (addr)
	{
		unsigned char code[16];
		int size = 0;
		code[size++] = 0x33;
		code[size++] = 0xC0;
		code[size++] = 0xC2;
		code[size++] = 0x04;
		code[size++] = 0x00;
		DWORD dwOldFlag, dwTempFlag;
		VirtualProtect(addr, size, PAGE_READWRITE, &dwOldFlag);
		WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL);
		VirtualProtect(addr, size, dwOldFlag, &dwTempFlag);
	}
}

class WareException
{
public:
	WareException()
	{
		//使其不再出现错误运算窗口
		SetErrorMode(SEM_FAILCRITICALERRORS);

		//Unhandled Exception出现的时候，定义所要运行的Callback
		m_PreviousExceptionFilter = SetUnhandledExceptionFilter( UnHandledExceptionFilter );

		m_se_translator_function = _set_se_translator( _se_trans_func );
		m_terminate_handler = set_terminate( terminate_func );
		m_unexpected_handler = set_unexpected( unexcepted_function );
		m_purecall_handler = _set_purecall_handler( _pure_call_handler );
		m_invalid_parameter_handler = _set_invalid_parameter_handler( InvalidParameterHandler );

		DisableSetUnhandledExceptionFilter();
	}

	~WareException(void)
	{
		SetUnhandledExceptionFilter( m_PreviousExceptionFilter );

		_set_se_translator( m_se_translator_function );
		set_terminate( m_terminate_handler );
		set_unexpected( m_unexpected_handler );
		_set_purecall_handler( m_purecall_handler );
		_set_invalid_parameter_handler( m_invalid_parameter_handler );
	}

private:

	LPTOP_LEVEL_EXCEPTION_FILTER      m_PreviousExceptionFilter;

	_se_translator_function           m_se_translator_function;
	terminate_handler                 m_terminate_handler;
	unexpected_handler                m_unexpected_handler;

	_invalid_parameter_handler        m_invalid_parameter_handler;

	_purecall_handler                 m_purecall_handler;
};

//END_WARECOMMON

