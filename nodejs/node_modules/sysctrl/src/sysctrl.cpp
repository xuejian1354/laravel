#include "sysctrl.h"
#include "DVR_NET_SDK.h"
#include "PTZ.h"

v8::Local<v8::Value> getValueFromObject(v8::Local<v8::Object> options, std::string key) {
  v8::Local<v8::String> v8str = Nan::New<v8::String>(key).ToLocalChecked();
  return Nan::Get(options, v8str).ToLocalChecked();
}

int getIntFromObject(v8::Local<v8::Object> options, std::string key) {
  return getValueFromObject(options, key)->ToInt32()->Int32Value();
}

bool getBoolFromObject(v8::Local<v8::Object> options, std::string key) {
  return getValueFromObject(options, key)->ToBoolean()->BooleanValue();
}

v8::Local<v8::String> getStringFromObj(v8::Local<v8::Object> options, std::string key) {
  return getValueFromObject(options, key)->ToString();
}

double getDoubleFromObject(v8::Local<v8::Object> options, std::string key) {
  return getValueFromObject(options, key)->ToNumber()->NumberValue();
}

void NetCamConn(NodeConnBaton* data) {
	NET_SDK_DEVICEINFO m_deviceInfo;
	ZeroMemory(&m_deviceInfo, sizeof(NET_SDK_DEVICEINFO));
	
	NET_SDK_CLIENTINFO clientInfo = {0};
	clientInfo.lChannel = 0;
	clientInfo.streamType = 0 /*NET_SDK_SUB_STREAM*/;

	NET_SDK_Init();
	NET_SDK_SetConnectTime(1000, 1);
	NET_SDK_SetReconnect();

	int userId = NET_SDK_Login(data->ipaddr, data->port, data->user, data->pass, &m_deviceInfo);
	if(userId > 0) {
		int playHandle = NET_SDK_LivePlay(userId, &clientInfo, NULL, NULL);
		data->playHandle = playHandle;
	}
	else {
		data->playHandle = -1;
	}

	data->userId = userId;
}

void NetCamCtrl(NodeCtrlBaton *data){
	if (data->playHandle > 0) {
		NET_SDK_PTZControl(data->playHandle, data->ctrlFlag, PTZ_SPEED_2);
	}
}

void NetCamClose(NodeCloseBaton *data) {
	if (data->playHandle > 0) {
		NET_SDK_StopLivePlay(data->playHandle);
	}

	if (data->userId > 0) {
		NET_SDK_Logout(data->userId);
	}

	NET_SDK_Cleanup();
}

NAN_METHOD(NodeConnect) {
	 if (!info[0]->IsObject()) {
		Nan::ThrowTypeError("First argument must be an object");
		return;
	  }
	  v8::Local<v8::Object> options = info[0]->ToObject();

	  if (!info[1]->IsFunction()) {
		Nan::ThrowTypeError("Second argument must be a function");
		return;
	  }
	  
	  NodeConnBaton* baton = new NodeConnBaton();
      memset(baton, 0, sizeof(NodeConnBaton));
	  
	  v8::String::Utf8Value ipaddr(getStringFromObj(options, "ipaddr"));
	  v8::String::Utf8Value user(getStringFromObj(options, "user"));
	  v8::String::Utf8Value pass(getStringFromObj(options, "pass"));
	  strcpy(baton->ipaddr, *ipaddr);
	  baton->port = getIntFromObject(options, "port");
	  strcpy(baton->user, *user);
	  strcpy(baton->pass, *pass);

	  baton->callback.Reset(info[1].As<v8::Function>());

      uv_work_t* req = new uv_work_t();
      req->data = baton;

      uv_queue_work(uv_default_loop(), req, EIO_NodeConnect, (uv_after_work_cb)EIO_AfterNodeConnect);
}

void EIO_NodeConnect(uv_work_t* req) {
	NodeConnBaton* data = static_cast<NodeConnBaton*>(req->data);
    NetCamConn(data);
}

void EIO_AfterNodeConnect(uv_work_t* req) {
	Nan::HandleScope scope;

    NodeConnBaton* data = static_cast<NodeConnBaton*>(req->data);

    v8::Local<v8::Value> argv[2];
    argv[0] = Nan::New<v8::Int32>(data->userId);
	argv[1] = Nan::New<v8::Int32>(data->playHandle);

    data->callback.Call(2, argv);

    delete data;
    delete req;
}

NAN_METHOD(NodeCtrl) {
	if (!info[0]->IsInt32()) {
      Nan::ThrowTypeError("First argument must be an int");
	  return;
    }
	
	if (!info[1]->IsInt32()) {
      Nan::ThrowTypeError("Second argument must be an int");
	  return;
    }

	NodeCtrlBaton* baton = new NodeCtrlBaton();
    memset(baton, 0, sizeof(NodeCtrlBaton));
    baton->playHandle = info[0]->ToInt32()->Int32Value();
	baton->ctrlFlag = info[1]->ToInt32()->Int32Value();

    uv_work_t* req = new uv_work_t();
    req->data = baton;

    uv_queue_work(uv_default_loop(), req, EIO_NodeCtrl, (uv_after_work_cb)EIO_AfterNodeCtrl);
}

void EIO_NodeCtrl(uv_work_t* req) {
    NodeCtrlBaton* baton = static_cast<NodeCtrlBaton*>(req->data);
	NetCamCtrl(baton);
}

void EIO_AfterNodeCtrl(uv_work_t* req) {
    delete req->data;
    delete req;
}

NAN_METHOD(NodeClose) {
	if (!info[0]->IsInt32()) {
      Nan::ThrowTypeError("First argument must be an int");
	  return;
    }

	if (!info[1]->IsInt32()) {
      Nan::ThrowTypeError("Second argument must be an int");
	  return;
    }
	
	NodeCloseBaton* baton = new NodeCloseBaton();
    memset(baton, 0, sizeof(NodeCloseBaton));
    baton->userId = info[0]->ToInt32()->Int32Value();
	baton->playHandle = info[1]->ToInt32()->Int32Value();

	uv_work_t* req = new uv_work_t();
	req->data = baton;

	uv_queue_work(uv_default_loop(), req, EIO_NodeClose, (uv_after_work_cb)EIO_AfterNodeClose);
}

void EIO_NodeClose(uv_work_t* req) {
	NodeCloseBaton* data = static_cast<NodeCloseBaton*>(req->data);
    NetCamClose(data);
}

void EIO_AfterNodeClose(uv_work_t* req) {
	Nan::HandleScope scope;

    int* ret = static_cast<int*>(req->data);

    delete ret;
    delete req;
}

extern "C" {
    void init(v8::Handle<v8::Object> target) {
        Nan::HandleScope scope;
        Nan::SetMethod(target, "netcamconn", NodeConnect);
		Nan::SetMethod(target, "netcamctrl", NodeCtrl);
		Nan::SetMethod(target, "netcamclose", NodeClose);
    }
}

NODE_MODULE(sysctrl, init);